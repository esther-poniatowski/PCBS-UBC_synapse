# PCBS-UBC_synapse


### Modeling signal filtering in the synapse between Mossy Fibers and Unipolar Brush Cells
---

The cerebellum is a brain area involved in the representation of movement and position. This high-level representation seems to be achieved through the integration and the disambiguation of sensory signals. This idea motivates to investigate the determinants of the signal processing, that might lie at the level of the neurons.  

In the cerebellum, the signal flows through a feedforward circuit :  
(1) It receives direct sensory inputs from the vestibular system of the inner ears, conveyed by the *Mossy Fibers (MFs)*. This signal is produced by sensors of inertial translational and rotational acceleration.  
(2) In the cerebellum, the mossy fibers contact the *Unipolar Brush Cells (UBCs)*.  
![Feedforward netword in the cerebellum](https://github.com/esther-poniatowski/PCBS-UBC_synapse/blob/master/fig1_cerebelllum_network.PNG)

The cerebellum features a high density of these remarkable interneurons, which display a very particular type of synapses. Indeed, the many convolutions of the UBCs' synaptic clefts lead to a giant contact surfaces, riddled with neurotransmitter release sites.  
This observation triggers the hypothesis that the synapse MF-UBC could play a role in the signal transformation, potentially by acting like a *filter*.  
**The goal of the project is to explore the influence of the synapse's morphological and physiological properties on the signal transformation.**

### Usage
---

Please use the Jupyter notebook provided.
The dependencies can be installed either via conda or virtualenv, thanks to the files environment.yml or requirements.txt.

### Progammation objectives
---

This project was drawn from an original project conducted in 2018-2019 in the context of an biology L3 intership, under the direction of Guillaume Dugu√©. Last year, carrying on this project was an opportunity for me to learn and practice programmation. Moreover, the goal was at first to investigate hypotheses about the synapse functions. Therefore, the codes I produced were hardly readable. 
For the current project, the focus was directed to getting in shape the original project. The aim was to provide a more sharable and automated tool, in view of further investigation based on the model.
The main work leads were the following :  
* Translating the code from R language to Python language.
* Optimizing the code. 
* Presenting the results in a notebook for simplifying the use.

I tried to implement was I had learned about Python in the context of PCBS and elsewhere:
* **Documentation** - I leaned about NumpyDocstyle syntax. I tried to provide as much details as possible in my modules, classes, and functions.
* **Don't Repeat Yourself** principle and Separation of Concerns. - In order to make the code more flexible and to automate the search of parameters, I rethought the architecture of the code, to make it more modular. I divided the tasks in different modules. Inside each module, I tried to break the unitary tasks in individual functions. It led me to start back from scratch on many aspects of the project. Namely, I implemented a new nethod to build the matrixes representing the synapses, after having considered in more depth the geometric constraints. 
* **Oriented Object Programming** - I wanted to practice for the first time Oriented Object Programming. For that purpose, I thought a modelling project was more favourable than data analysis. I built two classes to represent the synapses and the stimulation patterns. The classes provide functional interface for the user, without requiring to focus on the code details.
* **Packaging** - I readed about virtual environments and packages distribution. Even if my project is not meant to be distributed via Anaconda Cloud or PiPY, I tried to get the project in shape so that it could be shared. I built a "cookiecutter" template for my future projects. I listed the dependencies of my project in a file "requirements.txt".

### Statement of accounts
---

I met difficulties on several points:
* Compatibility between C and Python - Optimizing running times required to introduce the outputs yielded by a C code, in the Python code. To do so, the object types defined in Python have to fit specific formats, secified thanks to the library ctypes. However, as the results were not all registered in the target output variables, I am not sure that I specified them correctly, and I lacked time to investigate this issue.
* Organizing the project structure - I took time to settle on a satisfactory structure. What was the most challenging was to find a way to save the data generated by the codes. I opted for a separation in different folders according to the synapses, and a furher division in sub-folders according to the simulations. I chose to keep track of the saved data in register files (one for all the synapses, other ones for the simulations for each synapse). I built functions to scan the registers, and recover the objets if needed. Nevertheless, this approach complexified the codes, whereas the benefit was not considerable.
