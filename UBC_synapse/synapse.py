#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""Class for building synapses objects."""

__authors__ = ("esther-poniatowski")
__contact__ = ("esther.poniatowski@ens.fr")
__version__ = "1.0.0"
__date__ = "01/01/2020"

print("synapse successfully imported")

import numpy as np
import pandas as pd
import pickle
import os
import matplotlib.pyplot as plt
import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)
from UBC_synapse import create_matrix as cm
from UBC_synapse import patterns_release as ptr
from UBC_synapse import simulate as sim
from UBC_synapse import visualize as vis

class Synapse:
    """Synapse object, defined by morphological properties, functional properties, and behavior (responses).

    Attributes
    ----------
    dim : int
        Diameter of the target glomerulus (entire synapse), in px.
    n_sites : int
        Number of individual glutamate release sites.
    area_tot_sites : float
        Cumulative area of glutamate release, in m.
    res : float
        Sptatial resolution of the model in m. Conversion factor. 
    border_intra : int
        Margin in px between the most external synaptic area and the synapse border.
    border_extra : int
        Margin in px between the synapse border and the limit of the working matrix.
    I : array_like, dtype = int
        Matrix representing the glomerular area (entire synapse).
        It contains values "1" within a disk representing the synapse, and values "0" elsewhere.
    O : array_like, dtype = int
        Matrix representing the extraglomerular area. O is the mirror of I, obtained by 1 - I.
    S : array_like, dtype = int
        Matrix representing the individual synaptic sites areas.
        The synaptic areas are represented by values "1".
        The centers of the synaptic sites remain spotted by values "2".
        The other pixels contain values "0".
    M_site : array-like, dtype = int
        Small patch (matrix) representing a single synaptic site area.
    N_AMPA : int
        Number of AMPA channels per pixel of individual synaptic site.
    G_AMPA : float
        Conductance of AMPA channel.
    E_AMPA : float
        Inversion potential of AMPA channel.
    V0 : float
        Resting potential of the UBC's membrane.
    R : floats
        Resistance of the UBC's membrane.
        R = 1/G_leak, with G_leak = leak conductance.
    C : float
        Capacitance of the UBC's membrane.
    resp : dict
        Dictionary containing the response of the synapse to a particular stimulation. 
        It can be the result of the last simulation, or a response retrived from the saved data for the current synapse instance.
        The keys are the following:
        * 'coords': array of dimension (n, 2), containing the locations of the points where glutamate concentrations are recorded ([row, col]),
        * 'glus': list containing Series, each one being the evolution of the glutamate concentrations at a coordinate in 'coords',
        * 'AMPAtot': Series, evolution of the activation state of the AMPA channels (mean activation of the population),
        * 'V': Series, evolution of the UBC's membrane potential.
    path_data : str
        Class attribute, specifying the absolute path to the directory `UBC_data/`.
        This folder is meant to contain synapses' parameters, and the data generated by running simulations.
    register_syn : DataFrame
        Class attribute, table classifying the saved synapses, summarizing their major attributes.
        Columns:
        * 'dim'
        * 'n_sites'
        * 'area_tot_sites'
        * 'res'
        * 'border_intra'
        * 'border_extra'
        * 'N_AMPA'
        * 'E_AMPA'
        * 'V0'
        * 'R'
        * 'C'.
        The data is stored in the file `register_syn.csv`.
    synindex : int
        Reference of a given synapse instance in the table register_syn.
    dirname : 
        Absolute path to the directory containg the data relative to a given synapse instance.
        It points to a sub-folder in the directory `UBC_data/`, named according to the synapse index: `syn{index}/`.
    register_resp : DataFrame
        Table classifying the saved responses for the current instance, summarizing the major attributes of the patterns under which they were obtained.
        Index: References of the saved responses.
        Columns:         
        * 'mode'
        * 'tstep'
        * 'dur'
        * 'nit'
        * 'start'
        * 'n_stim'
        * 'f_stim'
        * 'fenv'
        * 'fmax'
        * 'fmin'.
        The data is stored in the file `register_responsesx.csv`, for synapse x. 
        The attribute is not None only if the synapse has aldready been registered. 
    respindex : int
         Reference of the response currently stored in the attribute resp, in the table register_resp.
    pattdata : dict
        Main attributes of the pattern under which the current response in resp was generated.
    
    Main methods
    ------------
    instantiate - Class method for instanciating several synapses.
    simulate_stimulation - Runs a simulation with the synapse, provided a stimulation pattern.
    save_response - Saves the last response computed for the synapse.
    visualize_self - Displays the synapse morphology.
    
    See also
    ----------
    create_matrix - Module for building the matrixes I, O, S, M_site.
    simulate - Module interfacing with the c_code, to simulate the behavior of a synapse in response to a stimulation pattern.
    patterns_release - Class for building a stimulation pattern.
    """

    # ==============================
    # Definition of class attributes
    # ==============================
    path_data = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) + '/UBC_data/'
    # Creation of a file 'register_syn.csv' if it does not exist:
    if 'register_syn.csv' not in os.listdir(path_data) :
        print("Creating a file 'register_syn.csv'.")
        register_syn = pd.DataFrame(columns=['dim', 'n_sites', 'area_tot_sites', 
                                            'res', 'border_intra', 'border_extra',
                                            'N_AMPA', 'E_AMPA', 'V0', 'R', 'C'])
        register_syn.to_csv(path_data+'register_syn.csv')
    # Loading the register of saved synapses:
    register_syn = pd.read_csv(path_data+'register_syn.csv', index_col=0)

    # ===========
    # Constructor
    # ===========
    def __init__(self, **kwargs):
        """
        Parameters
        ----------
        **kwargs : 
            Arguments corresponding to the desired values of the attributes.
            See the function create_all_matrixes from the module create_matrix for details about arguments and computations.
            Note: For "dim", "n_sites", The"area_tot_sites", the value provided by the user might not be the final attribute of the synapse instance.
            The final value, which becomes the attribute, is computed to match several constraints.
            dim : int
                Default value: None.
            n_sites : int
                Default value: 37.
            area_tot_sites : float
                Default value: 25e-12 m² (between 12 and 40 um², in vivo references given by Mungi).
            res : float
                Default value: 0.2e-6 m, corresponding to 1 px <=> 0.2 um. 
            border_intra : int
                Default value: 2 px.
            border_extra : int
                Default value: 2 px.
            N_AMPA : int
                Default value: 3.
            G_AMPA : float
                Default value: 20e-12 Ohm-1 (~10 pS)
            E_AMPA : float
                Default value: 0 mV
            V0 : float
                Default value: -75e-3 (-75 mV)
            R : float
                Default value: 652e6 (~100 MOhm, Van Drop 2014)
            C : float
                Default value: 17e-12 F (~10 pF, Van Drop 2014)
            verbose : bool, optional
                If True, the updated/suggested parameters and information will be printed.
                Default value: False.
        """
        self.res = kwargs.get('res', 0.2e-6)
        self.border_intra = kwargs.get('border_intra', 2)
        self.border_extra = kwargs.get('border_extra', 2)
        self.S, self.I, self.O, self.M_site, self.n_sites, self.area_tot_sites, self.dim = cm.create_all_matrixes(n_sites=kwargs.get('n_sites', 37), 
                                                verbose=kwargs.get('verbose', False),
                                                dim=kwargs.get('dim', None), 
                                                area_tot_sites=kwargs.get('area_tot_sites', 25e-12),
                                                res=self.res, border_intra=self.border_intra, border_extra=self.border_extra)
        self.N_AMPA = kwargs.get('N_AMPA', 3)        
        self.E_AMPA = kwargs.get('E_AMPA', 0)         
        self.G_AMPA = kwargs.get('G_AMPA', 20e-12)    
        self.V0 = kwargs.get('V0', -75e-3)         
        self.R = kwargs.get('R', 652e6 )          
        self.C = kwargs.get('C', 17e-12)
        self.resp = {'coords':sim.compute_coords_measures(self.S, self.M_site)}
        self.synindex = self.find_index_syn()
        self.dirname = None
        self.register_resp = None
        self.respindex = None
        self.pattdata = None
        
    @classmethod
    def instantiate(cls, dim_list, **kwargs):
        """Class method for instanciating several synapses with different dimensions.

        Parameters
        ----------
        dim_list : list of int
            Desired diameters in px for the distinct glomerules.
        **kwargs :
            Additional non default arguments, desired values for the attributes.

        Returns
        -------
        syn_dict : dictionary of Synapse instances.
            Keys: dimensions of the synapses
            Values: Synapses objects instanciated.

        See also
        --------
        __init__ - For the definition of the **kwargs arguments.
        """
        instances = (cls(dim=dim, **kwargs) for dim in dim_list)
        syn_dict = {str(inst.dim):inst for inst in instances}
        print("Synapses instanciated: {}".format(syn_dict.keys()))
        return syn_dict

    # =======
    # Methods
    # =======

    @classmethod
    def search_synapses(cls, verbose=False, **kwargs):
        """Class method for finding the saved synapses which feature desired properties.

        Parameters
        ----------
        **kwargs :
            Criteria for filtering the synapses. 
            The keys must belong to the columns of the table register_syn. See the class attrbute register_syn.columns.
        verbose : bool, optional
            If True, the indexes of found synapses are displayed.   

        Returns
        -------
        found : list of int
            References (indexes) of the candidate synapses, which feature desired properties.
        """
        # Listing the criteria to perform the filtering:
        filters = [key for key in kwargs.keys() if key in cls.register_syn.columns]
        # Scanning the register:
        found = [i for i,row in Synapse.register_syn.iterrows() if all(row[col]==kwargs[col] for col in filters)]
        if verbose :
            print("Indexes of found synapses: {}.".format(found))
        return found

    @classmethod
    def retrieve_synapse(cls, synindex):
        """Class method for loading a particular synapse which has already been saved before.

        Parameters
        ----------
        synindex : int
            Reference of the synapse in the table register_syn.

        Returns
        -------
        syn : Synapse object
        """
        print("Retrieving the synapse of index {}.".format(synindex))
        print(cls.path_data+'syn{}.pickle'.format(synindex))
        try :
            syn = pickle.load(open(cls.path_data+'syn{}/syn{}.pickle'.format(synindex, synindex), 'rb'))
            print("Successfully retrieved.")
        except :
            print("Synapse not registered yet.")
            syn = None
        finally :
            return syn

    def find_index_syn(self):
        """Method for attributing an index to the current intance."""
        names_instances = Synapse.register_syn.index
        if len(names_instances) == 0:      
            # Setting the index to 1 if the current instance if no synapse is registered
            print("No synapse registered yet.")
            self.synindex = 1
        else :
            # Defining criteria of identity for scanning the register:
            identity = {key:np.round(self.__dict__[key]) for key in self.__dict__.keys() if key in Synapse.register_syn.columns}
            found = Synapse.search_synapses(**identity)
            if len(found) != 0 :
                # Setting the index, if the current instance has already been saved before:
                self.synindex = found[0]
                print('Synapse already registered under index: {}'.format(self.synindex))
            else:
                # Setting the index to the next possible value:
                self.synindex = Synapse.register_syn.index.max() + 1

    def remember_responses(self, *kwargs):
        """Method for loading the file register_responses if it exists.
        It sets the attributes dirname and register_resp."""
        # Updating synindex
        self.find_index_syn()
        if self.synindex in Synapse.register_syn.index :
            print("Retrieving the register of saved responses for this synapse.")
            self.dirname = Synapse.path_data + 'syn{}/'.format(self.synindex)
            self.register_resp = pd.read_csv(self.dirname+'register_resp{}.csv'.format(self.synindex, self.synindex), index_col=0)
            print('Number of responses registered: {}'.format(len(self.register_resp)))
        else :
            print("No response registered yet.")
            return None

    def create_dir(self):
        """Method for creating a directory to save data for the current instance, if it does not exist yet.
        It sets the attribute "dirname".
        It creates a file `register_responsesx.csv` to classify the future simulations with the current instance.
        """
        # Updating synindex
        self.find_index_syn()
        self.dirname = Synapse.path_data + 'syn{}/'.format(self.synindex)
        if not os.path.exists(self.dirname):
            print("Creating a directory for the synapse of synindex {}.".format(self.synindex))
            os.makedirs(self.dirname)
            register_resp = pd.DataFrame(columns=['mode','tstep', 'dur', 'nit', 
                                                        'start', 'n_stim', 'f_stim', 
                                                        'fenv', 'fmin', 'fmax'])
            register_resp.to_csv(self.dirname+'register_resp{}.csv'.format(self.synindex))
        else :
            print("A directory already exists for the synapse of index {}.".format(self.synindex))
        self.remember_responses()

    def register_synapse(self):
        """Method for saving the current instance.
        It sets the attribute "dirname" and cretes the directory `syn{index}/`.
        It creates a file `register_responsesx.csv` to classify the future simulations with the current instance.
        """
        # Updating synindex
        self.find_index_syn()
        # Creating a dictionary summarizing the current instance:
        new_syn = {key:np.round((self.__dict__)[key]) for key in Synapse.register_syn.columns} # round for avoiding problems in the csv
        if (self.synindex not in Synapse.register_syn.index) :
            print("New synapse registration. Index: {}".format(self.synindex))
            # Appending a column in 'register_syn.csv':
            new_register = pd.concat([Synapse.register_syn, pd.DataFrame(new_syn, index=[self.synindex])])
            new_register.to_csv(Synapse.path_data+'register_syn.csv')
            Synapse.register_syn = new_register
            # Creating a directory for the instance:
            self.create_dir()
            # Saving the object:
            pickle.dump(self, open(self.dirname+'syn{}.pickle'.format(self.synindex), 'wb'))
        # Updating the attributes
        self.remember_responses()

    def search_responses(self, **kwargs):
        """Method for finding the saved responses which feature desired properties.

        Parameters
        ----------
        **kwargs :
            Criteria for filtering the responses. 
            The keys must belong to the columns of the table register_responsesx.
        Returns
        -------
        found : list of int
            References (indexes) of the candidate responses, which feature desired properties.
        """
        try :
            filters = [key for key in kwargs.keys() if key in self.register_resp.columns]
            found = [i for i,row in self.register_resp.iterrows() if all(row[col]==kwargs[col] for col in filters)]
            # print("Indexes of found responses: {}.".format(found))
            return found
        except : 
            return []

    def find_index_resp(self):
        """Method for attributing an intex to the response currently stored in the attribute resp."""
        if self.dirname == None :
            self.respindex = 1
            print("First response, index = 1.")
        else:
            names_instances = self.register_resp.index
            if len(names_instances) == 0:      
                # Setting the index to 1 if the current instance is the first synapse:
                self.respindex = 1
                print("First response, index = 1.")
            else :
                found = self.search_responses(**self.pattdata)
                if len(found) != 0 :
                    # Setting the index, if the current instance has already been saved before:
                    self.respindex = found[0]
                    print('Response already registered under index: {}'.format(self.respindex))
                else:
                    # Setting the index to the next possible value:
                    print('Response not registered yet.')
                    self.respindex = self.register_resp.index.max() + 1
                    # print("Setting the index to the next possible value: {}".format(self.synindex))

    def retrieve_response(self, respindex):
        """Method for loading a particular saved response.

        It fills the dictionary attribute "resp" with different components of the simulation. See the attribute definition for more details.
        
        Parameters
        ----------
        respindex : int
            Reference of the response in the table register_resp.
        """
        print('Retrieving the response of index {} for the synapse of index {}'.format(self.respindex, self.synindex))
        try :
            respdir = self.dirname + 'patt{}'.format(self.respindex)
            coords = pd.read_csv(respdir+'coords.csv')
            coords_ref = sim.coords_ref(coords)
            glus = (pd.read_csv(respdir+'resglu{}.csv'.format(ref)) for ref in coords_ref)
            resAMPAtot = pd.read_csv(respdir+'resAMPAtot.csv')
            resV = pd.read_csv(respdir+'resV.csv')
            self.resp = {'coords':coords,
                        'glus':glus, 
                        'AMPAtot':resAMPAtot, 
                        'V':resV}
        except :
            print("Response not registered yet.")


    def simulate_stimulation(self, patt, safe=False):
        """Method for running a simulation with the current instance.
 
        If the simulation has already been run previousely, the response is retrived in the attribute "resp".

        Parameters
        ----------
        patt : Pattern object
            Pattern 
        safe : bool
            If True, the content of the attribute resp is checked. 
            If it is not empty, the user will be ask whether to overwrite the content with a new simulation.
        **kwargs :

        See also
        --------
        seach_responses
        retrieve_response
        """
        # Storing the properties of the pattern in the attribut pattdata:
        self.pattdata = {key:patt.__dict__[key] for key in patt.__dict__.keys() if (key != 'params' and key != 'spat')}
        for key in patt.params :
            self.pattdata[key] = patt.params[key]
        print('1. Checking if a response is currently loaded in the attribute resp.')
        if self.respindex != None :
            choice = print(input('Do you want to overwrite the current stored response? [y/n]'))
            if choice == 'n' :
                return None
        else :
            print("resp is empty. Proceeding.")
        print('2. Checking if a response has already been computed for this pattern.')
        # Updating synindex and the register
        self.remember_responses()
        if self.dirname == None :
            compute = True
        else :
            self.find_index_resp()
            if self.respindex not in self.register_resp.index :
                compute = True
            else :
                compute = False
        # Running the simulation if necessary:
        if compute :
            print('3. Running the simulation. It may take some time.')
            coords, glus, resAMPAtot, resV = sim.execute_c_code(self, patt)
            self.resp = {'coords':coords,
                        'glus':glus, 
                        'AMPAtot':resAMPAtot, 
                        'V':resV}
            print("Simulation completed.")
        else:
            self.find_index_resp()
            print('Retrieving the response. Index: {}'.format(self.respindex))
            self.retrieve_response(self.respindex)

    def save_response(self):
        """Method for saving the loaded respons of the current instance.
        It registers the synapse if it has never been saved before.
        It creates a directory for the response, in the subfolder corresponding to the synapse instance.
        """
        # Update synindex
        self.find_index_syn()
        print("1. Finding the location of the data of this synapse.")
        # Registration of the synapse if needed:
        self.register_synapse()
        print("2. Attributing an index to the response.")
        self.find_index_resp()
        print("3. Creating a directory for this response and saving the response.")
        respdir = self.dirname + 'patt{}/'.format(self.respindex)
        try :
            os.makedirs(respdir)
            # Exporting the contents of the attribute "resp" to csv files:
            coords_ref = sim.coords_ref(self.resp['coords'])
            pd.DataFrame(self.resp['coords']).to_csv(respdir+'coords.csv')
            for i in range(len(coords_ref)) :
                self.resp['glus'][i].to_csv(respdir+'resglu{}.csv'.format(coords_ref[i]))
            self.resp['AMPAtot'].to_csv(respdir+'resAMPAtot.csv')
            self.resp['V'].to_csv(respdir+'resV.csv')
            # Updating register_resp
            new_register = pd.concat([self.register_resp, pd.DataFrame(self.pattdata, index=[self.respindex])])
            new_register.to_csv(self.dirname+'register_resp{}.csv'.format(self.synindex))
            self.register_resp = new_register
            print("Saved.")
        except FileExistsError :
            print("Response already registered.")


    def visualize_self(self, print_coords=False):
        """Method for displaying the matrixes representing the synapse.
 
        Parameters
        ----------
        print_coords : bool, optional
            If True, the points where glutamate concentrations were recorded will be displayed.

        See also
        --------
        print_matrix in the module visualize
        """
        S = self.S.copy()
        I = self.I.copy()
        if print_coords :
            vis.print_matrix(S, I, self.res, print_coords=True, coords=self.resp['coords'])
        else :
            vis.print_matrix(S, I, self.res)